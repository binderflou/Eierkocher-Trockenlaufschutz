# Design
## Klassendiagramm

![Klassendiagramm](../referenziert/Design/KlassendiagrammSoftwareEngineering.png)

# üß© Klassendiagramm ‚Äì Trockenlaufschutz f√ºr Eierkocher

## 1. Zweck des Klassendiagramms
Das Klassendiagramm beschreibt die objektorientierte Struktur der Software f√ºr den **Trockenlaufschutz eines Eierkochers**.  
Es dient der logischen Modellierung aller wesentlichen Systemkomponenten und stellt deren **Verantwortlichkeiten, Attribute, Methoden und Beziehungen** dar.  
Die Architektur folgt dem **Schichtenmodell** aus:

- **UserInterface** (Anzeige, Ton, Eingabe)  
- **Steuerungslogik** (Systemsteuerung, Zustandsmanagement, Sicherheit)  
- **HardwareAbstraction** (Sensor- und Aktorsteuerung)  
- **PersistenceManager** (Datenspeicherung und Kalibrierung)

Dieses Diagramm bildet die Grundlage f√ºr die Implementierung auf einem **Arduino Nano** mit C++.

---

## 2. √úberblick √ºber die Struktur
Die Software besteht aus vier Hauptschichten mit den zugeh√∂rigen Klassen:

| **Schicht** | **Klassen** | **Beschreibung** |
|--------------|-------------|------------------|
| **UserInterface** | `DisplayController`, `BuzzerController`, `InputHandler` | Verwaltung von Anzeige, akustischer Signalisierung und Benutzereingaben |
| **Steuerungslogik** | `SystemController`, `StateDetector`, `SafetyManager`, `ThresholdManager` | Zentrale Steuerung, Zustands√ºberwachung und Sicherheitslogik |
| **HardwareAbstraction** | `FillLevelSensor`, `TemperatureSensor`, `HeaterControl`, `TimerService` | Ansteuerung und Abstraktion der Sensoren und Aktoren |
| **PersistenceManager** | `CalibrationData`, `SettingsStorage` | Verwaltung von Kalibrierungsdaten und Persistenzspeicherung |

---

## 3. Klassendokumentation

### 3.1 `SystemController`
**Rolle:** Hauptsteuerung der Anwendung  
**Schicht:** Steuerungslogik  

**Aufgaben:**
- F√ºhrt den Hauptzyklus (`loop`) aus  
- Liest Sensordaten ein  
- Pr√ºft Zust√§nde und Sicherheitsbedingungen  
- Steuert Anzeige, Summer und Heizung  

**Attribute:**
- `fillSensor : FillLevelSensor`  
- `tempSensor : TemperatureSensor`  
- `heater : HeaterControl`  
- `ui : DisplayController`  
- `buzzer : BuzzerController`  

**Methoden:**
- `setup()` ‚Äì Initialisierung von Komponenten  
- `executeCycle()` ‚Äì Ablaufsteuerung  
- `handleError(errorCode : int)` ‚Äì Fehlerbehandlung  
- `updateSystemState()` ‚Äì Zustandslogik aktualisieren  

---

### 3.2 `StateDetector`
**Rolle:** Erkennung des aktuellen Systemzustands (Bereit, Warnung, Trockenlauf, Fehler)  
**Schicht:** Steuerungslogik  

**Aufgaben:**
- Auswertung von F√ºllstand und Temperatur  
- R√ºckgabe eines logischen Zustands zur Anzeige und Steuerung  

**Attribute:**
- `currentState : string`  
- `fillLevel : int`  
- `temperature : float`  

**Methoden:**
- `detectState(fillLevel : int, temperature : float) : string`  
- `getState() : string`

---

### 3.3 `SafetyManager`
**Rolle:** √úberwachung und Schutzfunktionen  
**Schicht:** Steuerungslogik  

**Aufgaben:**
- Pr√ºft Trockenlaufbedingungen  
- L√∂st Sicherheitsabschaltung aus  
- Verwaltet Fail-Safe-Verhalten  

**Attribute:**
- `dryRunDetected : bool`  

**Methoden:**
- `checkDryRun(fillLevel : int, tempRise : float) : bool`  
- `emergencyShutdown()` ‚Äì Heizung abschalten  

---

### 3.4 `DisplayController`
**Rolle:** Anzeige der Systemzust√§nde  
**Schicht:** UserInterface  

**Aufgaben:**
- Aktualisiert die Displayanzeige (F√ºllstand, Temperatur, Warnungen, Fehler)  
- Steuert farbliche und symbolische Darstellung  

**Attribute:**
- `fillLevelDisplay : int`  
- `temperatureDisplay : int`  
- `warningMessage : string`  

**Methoden:**
- `updateDisplay(fillLevel : int, temperature : int, status : string)`  
- `showWarning(message : string)`  
- `clearDisplay()`  

---

### 3.5 `BuzzerController`
**Rolle:** Akustische Signalisierung  
**Schicht:** UserInterface  

**Aufgaben:**
- Ausgabe von Warn- und Fehlert√∂nen  
- Steuerung der Signalarten (kurz/lang)  

**Attribute:**
- `buzzerPin : int`  

**Methoden:**
- `playWarningTone()`  
- `playErrorTone()`  
- `stopTone()`  

---

### 3.6 `InputHandler`
**Rolle:** Benutzerinteraktion (Taster/Encoder)  
**Schicht:** UserInterface  

**Aufgaben:**
- Liest Eingaben ein  
- √úbermittelt Benutzeraktionen an die Steuerlogik  

**Attribute:**
- `buttonPin : int`  
- `buttonState : bool`  

**Methoden:**
- `readInput() : bool`  
- `isButtonPressed() : bool`

---

### 3.7 `FillLevelSensor`
**Rolle:** Erfassung des Wasserstands  
**Schicht:** HardwareAbstraction  

**Aufgaben:**
- Liest analogen Sensorwert  
- Berechnet Prozentf√ºllstand  
- Pr√ºft Messwert auf Plausibilit√§t  

**Attribute:**
- `analogPin : int`  
- `fillLevelPercent : int`  

**Methoden:**
- `readLevel() : int`  
- `isValid() : bool`

---

### 3.8 `TemperatureSensor`
**Rolle:** Messung der Temperatur  
**Schicht:** HardwareAbstraction  

**Aufgaben:**
- Liest Temperaturwert (NTC oder DS18B20)  
- Berechnet Temperatur√§nderungsrate  

**Attribute:**
- `tempPin : int`  
- `temperature : float`  

**Methoden:**
- `readTemperature() : float`  
- `getDeltaT() : float`

---

### 3.9 `HeaterControl`
**Rolle:** Steuerung der Heizleistung  
**Schicht:** HardwareAbstraction  

**Aufgaben:**
- Schaltet Heizelement √ºber Relais oder MOSFET  
- Pr√ºft Zustand der Heizung  

**Attribute:**
- `relayPin : int`  
- `isOn : bool`  

**Methoden:**
- `switchOn()`  
- `switchOff()`  
- `getStatus() : bool`

---

### 3.10 `SettingsStorage`
**Rolle:** Verwaltung persistenter Parameter  
**Schicht:** PersistenceManager  

**Aufgaben:**
- Laden und Speichern von Grenzwerten und Kalibrierungsdaten  
- Zugriff auf Fehlerhistorie  

**Attribute:**
- `warningThreshold : int`  
- `criticalThreshold : int`  

**Methoden:**
- `loadSettings()`  
- `saveSettings()`  
- `getCalibrationData() : CalibrationData`

---

### 3.11 `CalibrationData`
**Rolle:** Speicherung der Kalibrierungsdaten  
**Schicht:** PersistenceManager  

**Aufgaben:**
- Verwaltung der F√ºllstands- und Temperaturkennlinien  
- Bereitstellung von Korrekturwerten f√ºr Sensorik  

**Attribute:**
- `fillCalibValues : int[]`  
- `tempCalibValues : float[]`  

**Methoden:**
- `getFillCalib() : int[]`  
- `getTempCalib() : float[]`

---

## 4. Beziehungen zwischen den Klassen

| **Beziehung** | **Beteiligte Klassen** | **Beschreibung** |
|----------------|------------------------|------------------|
| Aggregation | `SystemController` ‚Üí `FillLevelSensor`, `TemperatureSensor`, `HeaterControl`, `DisplayController` | Zentrale Steuerung besitzt und verwendet diese Komponenten |
| Assoziation | `SystemController` ‚Üî `SafetyManager`, `StateDetector` | Logische Zusammenarbeit bei Zustandspr√ºfung |
| Komposition | `UserInterface` ‚Üî `DisplayController`, `BuzzerController`, `InputHandler` | UI besteht aus diesen Subkomponenten |
| Abh√§ngigkeit | `Steuerungslogik` ‚Üí `PersistenceManager` | Steuerlogik nutzt gespeicherte Parameter |
| Aggregation | `SettingsStorage` ‚Üí `CalibrationData` | Persistenzmodul enth√§lt Kalibrierdatenobjekt |

---

## 5. Zusammenhang mit Anforderungen

| **Requirement-ID** | **Betroffene Klassen** | **Beschreibung** |
|---------------------|------------------------|------------------|
| R1.1, R1.2 | `FillLevelSensor`, `TemperatureSensor` | Erfassen und Filtern von Messwerten |
| R2.1‚ÄìR3.3 | `SystemController`, `StateDetector`, `SafetyManager` | Zustandslogik und Sicherheits√ºberwachung |
| R4.1‚ÄìR4.3 | `SettingsStorage`, `CalibrationData` | Selbsttest, Fehlerdiagnose, Datenspeicherung |
| R5.1‚ÄìR5.5 | `DisplayController`, `BuzzerController`, `InputHandler` | Anzeige, Warnungen und Benutzerinteraktion |

---

## 6. Fazit

Das Klassendiagramm gew√§hrleistet eine **klare Trennung der Verantwortlichkeiten** und eine **testbare modulare Struktur**.  
Durch die Schichtenarchitektur ist das System:
- **erweiterbar** (z. B. Bluetooth-Diagnose, Logging),
- **fehlertolerant** (Sicherheitsabschaltung √ºber SafetyManager),
- **wartbar** (klare Schnittstellen),
- und **hardwareunabh√§ngig** (dank Abstraktionsschicht).

Damit erf√ºllt die Architektur die funktionalen und nicht-funktionalen Anforderungen aus dem Pflichtenheft vollst√§ndig.


## Sequenzdiagramm

![Sequenzdiagramm](../referenziert/Design/SequenzdiagrammSoftwareEngineering.png)

## Kommunikationsdiagramm

![Kommunikationsdiagramm](../referenziert/Design/Kommunikationsdiagramm1.png)


# Softwarearchitektur ‚Äì Design-Komponenten

```mermaid
graph TD
    %% Schicht 1: Sensordatenerfassung
    subgraph Sensordatenerfassung
        FILL[F√ºllstandsmessung]
        TEMP[Temperaturmessung]
        TIME[Zeitgeber]
    end

    %% Schicht 2: Datenverarbeitung & Zustands√ºberwachung
    subgraph Auswerte-Steuerlogik
        DAT[Sensor-Datenverarbeitung]
        SIV[Soll/Ist-Vergleich]
        STATUS[Statusverwaltung]
    end

    %% Schicht 3: Steuerlogik & Sicherheit
    subgraph Steuerung
        HEAT[Heizungssteuerung]
        SAFETY[Trockenlaufschutz/Sicherheitsmodus]
    end

    %% Schicht 4: Benutzerinterface
    subgraph UI
        DISPLAY_FILL[F√ºllstandsanzeige]
        DISPLAY_TEMP[Temperaturanzeige]
        WARN[Warn- & Fehlermeldung]
    end

    %% Schicht 5: Test & Diagnose
    subgraph Test_und_Diagnose
        SELFTEST[Selbsttest & Plausibilit√§tspr√ºfung]
        ERROR[Fehleranalyse]
    end

    %% Datenfl√ºsse zwischen den Komponenten
    FILL --> DAT
    TEMP --> DAT
    TIME --> DAT
    DAT --> SIV
    SIV --> STATUS
    STATUS --> HEAT
    STATUS --> SAFETY
    STATUS --> DISPLAY_FILL
    STATUS --> DISPLAY_TEMP
    STATUS --> WARN
    SELFTEST --> DAT
    SELFTEST --> SIV
    SELFTEST --> WARN
    ERROR --> STATUS
    ERROR --> WARN
````

# Software-Design-Komponenten

Die folgende Tabelle zeigt die Zerlegung der Architektur-Ebenen (Sensorik, Auswertelogik, Steuerlogik, Benutzerinterface)  
in kleinere Software-Design-Komponenten.  
Diese Beschreibung erfolgt **ohne objektorientierte Modellierung** (also nur Funktionsbl√∂cke).

| **Architektur-Ebene** | **Software-Design-Komponente** | **Aufgabe / Beschreibung** | **Eingabe** | **Ausgabe** |
|------------------------|--------------------------------|-----------------------------|--------------|--------------|
| **Sensorik** | `FillLevelReader` | Erfasst den analogen F√ºllstandswert, normiert auf 0‚Äì100 %, filtert Messrauschen. | Analoge Spannung (0‚Äì3,3 V) | Prozentwert (0‚Äì100 %), gefiltert |
|  | `TemperatureReader` | Liest Temperatur √ºber NTC oder DS18B20, berechnet Temperaturdifferenz ŒîT/Œît. | Digitalwert / Widerstand | Temperaturwert in ¬∞C, √Ñnderungsrate |
|  | `SensorValidator` | Pr√ºft Sensordaten auf Plausibilit√§t (0‚Äì100 %, 0‚Äì150 ¬∞C). | Messwerte | Status: OK / Fehlercode |
| **Auswertelogik** | `DataFilter` | Gleitender Mittelwert √ºber letzte n Messpunkte, um Schwankungen zu gl√§tten. | Rohdaten | Gefilterte Werte |
|  | `StateDetector` | Erkennt Systemzustand (Bereit, Warnung, Trockenlauf, √úberhitzung). | Sensordaten | Zustandskennung |
|  | `ThresholdManager` | Verarbeitet benutzerdefinierte Warnschwelle (10‚Äì50 %). | Eingabewert | Grenzwert |
|  | `DryRunDetector` | Ermittelt Trockenlauf anhand F√ºllstand < 10 % oder ŒîT > 5 ¬∞C/s. | Sensordaten | Trockenlauf-Flag |
| **Steuerlogik** | `HeaterControl` | Steuert Relais/MOSFET zur Heizungsabschaltung bei kritischem Zustand. | Zustand, Sensorwerte | Schaltsignal (Ein/Aus) |
|  | `SafetyManager` | Koordiniert Sicherheitsabschaltung bei Trockenlauf, √úberhitzung, Sensorfehler. | Fehlerstatus | Relais Aus, Warnsignal |
|  | `SystemController` | Hauptzyklus: liest Sensoren, aktualisiert Zust√§nde, steuert UI und Heizung. | Alle Daten | Steuerbefehle |
|  | `SelfTestManager` | F√ºhrt Start-Selbsttest und zyklische Pr√ºfungen durch. | Sensorstatus | Testresultat / Fehlercode |
| **Benutzerinterface (UI)** | `DisplayController` | Zeigt Werte, Warnungen und Fehler an (Farbcode, Text, Symbole). | Zustand, Messdaten | LCD-Ausgabe |
|  | `BuzzerController` | Erzeugt akustische Warnsignale (2√ó kurz, 3√ó lang). | Fehlerzustand | Tonmuster |
|  | `InputHandler` | Liest Taste / Encoder, verarbeitet Quittierungen und Einstellungen. | Benutzereingabe | Befehle an Steuerlogik |
| **Systemdienste** | `TimerService` | Zeitbasis f√ºr Messintervalle, Selbsttest, Blinken etc. | Systemzeit | Zeitstempel, Timer-Ereignisse |
|  | `Logger` *(optional)* | Speichert Fehlerhistorie und Betriebsdaten (z. B. Trockenlaufz√§hler). | Ereignisse | Logdaten |
|  | `CommInterface` *(optional)* | Schnittstelle f√ºr serielle Diagnose oder Bluetooth. | Datenpakete | Debug-/Diagnosedaten |

